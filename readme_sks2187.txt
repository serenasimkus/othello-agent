Serena Simkus
sks2187
COMS 4701
Assignment 2: Othello

For my minimax algorithm, I started by following the pseudocode in the textbook on pg. 166. For my alpha-beta pruning algorithm, I started by following the pseudocode in the textbook on pg. 170. For both of these algorithms, I basically followed the pseudocode provided exactly, except I put the first 'wrapper' function within my get_move function, differentiating between minimax and alpha-beta using the self.alpha_beta class attribute provided (as suggested in the assignment). I started with pure minimax and alpha-beta pruning algorithms, but as I worked on the heuristic and added functionality (like taking into account remaining time, the experiments, etc.), I ended up adding a lot more to the basic algorithms. 
For the terminal test, I decided a game/move was over when either the board was filled, or if either player didn't have a move left, or if the depth had been decremented to 0. If any of these terminal tests were true, then in the min/max functions for both minimax and alpha-beta, I called the utility test, which was my heuristic. For a simple call of the heuristic function, I took into account positioning, mobility (for earlier moves), and stability. I wrote a function for stability that checks the stability of a move by taking the board and each piece, and seeing if that piece can be taken by the opponent in the next move by checking in all eight directions from that piece, if there is an opponent piece on one side, and a series of my own pieces on the other side, followed by a blank space (meaning that piece could be taken by the opponent in the next move). Unstable pieces receive a value of -1, and stable pieces receive a value of 1. I then go through my pieces, and the opponents pieces, and calculate the stability multiplied by the positional value, and add them up for my pieces, and subtract them for my opponent's stability value. I also made a grid to keep track of the positional values, weighting the corners with the highest values, and weighting the spaces adjacent to the corners with negative values, and putting emphasis on edges, and smaller values on pieces closer to the center of the board. I multiplied the stability values by these positional values, but also created a variable to measure the positional weights and factored this separately by weighting the value of the move on the board. I take the mobility into account early on in the game, so in the first 7 moves I track the mobility as the number of moves I have minus the number of moves my opponent has, and weight this heavily. For moves 7 to 9 I also count the mobility, but weight it slightly less. I chose to do this because I know mobility is extremely important in the early stages of the game. I got a lot of my general ideas about strategy from the first link listed, and I read some of the paper in the second link to get an idea of what I should use and what the terms meant. 
In addition to the utility function, I took a couple other aspects of the game into consideration to improve my strategy. First, I took time into account. I kept track of how much time I had spent in a move, and compared it to the time remaining, and when this time got too low, I just made random moves so that I would at least make some move and not run out of time and lose for sure. I also knew that I wanted to attack corner pieces very heavily, so I changed my strategy to always take a corner piece if it is in my legal moves at the start of a turn, but only after 8 moves. I had noticed that even though I weighted corner pieces a lot higher in my heuristic, when I played games I still didn't always get the corners very often, so I decided that I would make that a higher priority by returning the corner no matter what. This also helped with time because those moves wouldn't take as long. Another choice I made for alpha-beta pruning was to order the moves based on a shorter heuristic function (using only the weights of the positions of pieces, corners and edges highest) when I first get the moves, so that pruning can be more effective. I was having some issues with the time that the moves were taking towards the middle of the game, the moves in the beginning and the end would be fast, but in the middle there were a lot more moves, so I decided to check the number of moves each turn had, and if it had 18 or more moves, I went one less level deep into the tree. This way I was able to go deeper for most moves, but cut down a lot of time for moves that would have taken a long time because of how many nodes there were to explore. 
For minimax my depth is set to 3 (which should be 4 ply), and for alpha-beta I have my depth set to 4 (which should be 5 ply), and set to 3 (4 ply) when there are 18 or more moves. I run alpha-beta with 60 seconds and it beats greedy as both the black and white engine, and wins against random over half of the time as the black engine, and over half of the time as the white engine (although it wins more times when I am the white engine). I run minimax with 350 seconds and it also beats greedy both ways. 


Sources used:
http://www.samsoft.org.uk/reversi/strategy.htm - general strategy
http://ceur-ws.org/Vol-1107/paper2.pdf - more detailed

pg. 166 and pg. 170 - textbook